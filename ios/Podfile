# Resolve react_native_pods.rb with node to allow for hoisting
require Pod::Executable.execute_command('node', ['-p',
  'require.resolve(
    "react-native/scripts/react_native_pods.rb",
    {paths: [process.argv[1]]},
  )', __dir__]).strip

platform :ios, min_ios_version_supported
prepare_react_native_project!

linkage = ENV['USE_FRAMEWORKS']
if linkage != nil
  Pod::UI.puts "Configuring Pod with #{linkage}ally linked Frameworks".green
  use_frameworks! :linkage => linkage.to_sym
end

use_frameworks! :linkage => :static

# Patch React Native scripts that break when the project path contains spaces.
# IMPORTANT: this must run while the Podfile is being evaluated (before `use_react_native!`)
# because some script phases are generated during Podfile parsing.
rn_root = File.expand_path(File.join(__dir__, '..', 'node_modules', 'react-native'))

script_phases_rb = File.join(rn_root, 'scripts', 'react_native_pods_utils', 'script_phases.rb')
if File.exist?(script_phases_rb)
  contents = File.read(script_phases_rb)
  patched = contents.dup

  # Quote exports so paths with spaces don't get split by the shell.
  patched.gsub!(
    /'RCT_SCRIPT_RN_DIR'\s*=>\s*"\$RCT_SCRIPT_POD_INSTALLATION_ROOT\/#\{options\[:react_native_path\]\}"/,
    "'RCT_SCRIPT_RN_DIR' => \"\\\"$RCT_SCRIPT_POD_INSTALLATION_ROOT/\#{options[:react_native_path]}\\\"\"",
  )
  patched.gsub!(
    /'RCT_SCRIPT_APP_PATH'\s*=>\s*"\$RCT_SCRIPT_POD_INSTALLATION_ROOT\/#\{options\[:relative_app_root\]\}"/,
    "'RCT_SCRIPT_APP_PATH' => \"\\\"$RCT_SCRIPT_POD_INSTALLATION_ROOT/\#{options[:relative_app_root]}\\\"\"",
  )
  patched.gsub!(
    /'RCT_SCRIPT_OUTPUT_DIR'\s*=>\s*"\$RCT_SCRIPT_POD_INSTALLATION_ROOT"/,
    "'RCT_SCRIPT_OUTPUT_DIR' => \"\\\"$RCT_SCRIPT_POD_INSTALLATION_ROOT\\\"\"",
  )

  if patched != contents
    File.write(script_phases_rb, patched)
    Pod::UI.puts "Patched React Native script_phases.rb to support spaces in paths".green
  end
end

with_env_sh = File.join(rn_root, 'scripts', 'xcode', 'with-environment.sh')
if File.exist?(with_env_sh)
  contents = File.read(with_env_sh)
  patched = contents.gsub(/\n(\s*)\$1\n/, "\n\\1\"$1\"\n")
  if patched != contents
    File.write(with_env_sh, patched)
    Pod::UI.puts "Patched React Native with-environment.sh to quote script invocation".green
  end
end

codegen_executor_js = File.join(
  rn_root,
  'scripts',
  'codegen',
  'generate-artifacts-executor.js',
)
if File.exist?(codegen_executor_js)
  contents = File.read(codegen_executor_js)
  patched = contents.gsub(
    %q(/bin/sh -c "$WITH_ENVIRONMENT $SCRIPT_PHASES_SCRIPT"),
    %q("$WITH_ENVIRONMENT" "$SCRIPT_PHASES_SCRIPT"),
  )
  if patched != contents
    File.write(codegen_executor_js, patched)
    Pod::UI.puts "Patched React Native generate-artifacts-executor.js to support spaces in paths".green
  end
end

target 'candidates_app' do
  config = use_native_modules!

  use_react_native!(
    :path => config[:reactNativePath],
    # An absolute path to your application root.
    :app_path => "#{Pod::Config.instance.installation_root}/.."
  )


  pod 'Firebase/Firestore'

  post_install do |installer|
    # https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L197-L202
    react_native_post_install(
      installer,
      config[:reactNativePath],
      :mac_catalyst_enabled => false,
      # :ccache_enabled => true
    )

    # Fix CocoaPods-generated script phases when the project path contains spaces
    # (e.g. ".../Jeremy Nassau/..."). Without this, Xcode runs:
    #   /bin/sh -c "$WITH_ENVIRONMENT $SCRIPT_PHASES_SCRIPT"
    # which breaks into "/Users/.../Jeremy" and fails.
    installer.pods_project.targets.each do |target|
      target.build_phases.each do |phase|
        next unless phase.is_a?(Xcodeproj::Project::Object::PBXShellScriptBuildPhase)
        next unless phase.shell_script

        phase.shell_script = phase.shell_script.gsub(
          %q(/bin/sh -c "$WITH_ENVIRONMENT $SCRIPT_PHASES_SCRIPT"),
          %q("$WITH_ENVIRONMENT" "$SCRIPT_PHASES_SCRIPT")
        )
      end
    end

    installer.pods_project.save

    # Fix iOS builds failing with `non-modular-include-in-framework-module` when using frameworks.
    # This can be triggered by `use_frameworks!` (even static) across some React Native / Pods targets.
    installer.pods_project.targets.each do |t|
      t.build_configurations.each do |bc|
        bc.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'

        # Some targets add -Werror=non-modular-include-in-framework-module; remove it if present.
        ['OTHER_CFLAGS', 'OTHER_CPLUSPLUSFLAGS'].each do |k|
          v = bc.build_settings[k]
          next if v.nil?

          flags =
            if v.is_a?(String)
              v.split(' ')
            elsif v.is_a?(Array)
              v
            else
              []
            end

          flags = flags.reject { |f| f == '-Werror=non-modular-include-in-framework-module' }
          bc.build_settings[k] = v.is_a?(String) ? flags.join(' ') : flags
        end
      end
    end

    # Fix Hermes "error opening archive" when project path contains spaces.
    # The generated Hermes script calls `tar -xf` without quoting the tarball path.
    hermes_scripts = Dir.glob(File.join(installer.sandbox.root.to_s, '**', '*hermes*', '*.sh'))
    hermes_scripts += Dir.glob(File.join(installer.sandbox.root.to_s, '**', '*hermes*', '*.command'))
    hermes_scripts.uniq.each do |path|
      next unless File.file?(path)

      contents = File.read(path)
      next unless contents.include?('tar -xf')
      next unless contents.include?('hermes')

      # Quote common tarball variable expansions if unquoted.
      patched = contents
        .gsub(/tar\s+-xf\s+\$\{?HERMES_TARBALL\}?/,'tar -xf "${HERMES_TARBALL}"')
        .gsub(/tar\s+-xf\s+\$\{?TARBALL\}?/,'tar -xf "${TARBALL}"')
        .gsub(/tar\s+-xf\s+\$\{?HERMES_ENGINE_TARBALL\}?/,'tar -xf "${HERMES_ENGINE_TARBALL}"')

      if patched != contents
        File.write(path, patched)
      end
    end
  end
end
